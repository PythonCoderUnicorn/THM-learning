#SQL #SQLi 

https://tryhackme.com/r/room/advancedsqlinjection


pre-reqs:
- https://tryhackme.com/r/room/sqlinjectionlm   ✅
- https://tryhackme.com/r/room/sqlmap (not finished)
- https://tryhackme.com/r/room/owasptop10   ✅
- https://tryhackme.com/r/room/furthernmap  ✅


SQL injection remains one of web applications' most severe and widespread security vulnerabilities. This threat arises when an attacker exploits a web application's ability to execute arbitrary SQL queries, leading to unauthorised access to the database, data exfiltration, data manipulation, or even complete control over the application. In this room, we will understand advanced SQL injection techniques, providing a comprehensive understanding of sophisticated attack vectors and mitigation strategies.

> [! info] You can start the virtual machine by clicking the `Start Machine` button attached to this task. You may access the VM using the AttackBox or your VPN connection. Later in the room, we will use a vulnerable application to perform the exercise practically and familiarise ourselves with various attack vectors. Please wait 1-2 minutes after the system boots completely to let the auto scripts run successfully.

```
nmap -A -T4 -p 3306,3389,445,139,135 $IP
```



## quick recap 

In the last SQL injection room, we explored the basics of SQL injection, understanding how attackers exploit vulnerabilities in web applications to manipulate SQL queries and access unauthorised data. We covered essential techniques, such as error-based and union-based SQL injection, and blind SQL injection methods, such as boolean-based and time-based attacks. Here is a quick recap of the room covering the core essential types of SQL injection.

```
SQL Injection types

in-band
	error based
	union based

out-of-band

inferential
	boolean based
	time based
```


### In-band SQL Injection

This technique is considered the most common and straightforward type of SQL injection attack. In this technique, the attacker uses the same communication channel for both the injection and the retrieval of data. There are two primary types of in-band SQL injection:  

- **Error-Based SQL Injection**: The attacker manipulates the SQL query to produce error messages from the database. These error messages often contain information about the database structure, which can be used to exploit the database further. 
	
	- If the database version is returned in the error message, it reveals information about the database.

```sql
SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))
```

- **Union-Based SQL Injection**: The attacker uses the UNION SQL operator to combine the results of two or more SELECT statements into a single result, thereby retrieving data from other tables. 

```sql
SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin
```


### Inferential (Blind) SQL Injection  

Inferential SQL injection does not transfer data directly through the web application, making exploiting it more challenging. Instead, the attacker sends payloads and observes the application’s behaviour and response times to infer information about the database. There are two primary types of inferential SQL injection:  

- **Boolean-Based Blind SQL Injection**: The attacker sends an SQL query to the database, forcing the application to return a different result based on a true or false condition. By analysing the application’s response, the attacker can infer whether the payload was true or false. 
- The attacker can infer the result if the page content or behaviour changes based on the condition.
 
 ```sql
SELECT * FROM users WHERE id = 1 AND 1=1 versus SELECT * FROM users WHERE id = 1 AND 1=2    
```

- **Time-Based Blind SQL Injection**: The attacker sends an SQL query to the database, which delays the response for a specified time if the condition is true. By measuring the response time, the attacker can infer whether the condition is true or false. 
 - If the response is delayed by 5 seconds, the attacker can infer that the condition was true.

```sql
SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY '00:00:05'--
```


### Out-of-band SQL Injection

Out-of-band SQL injection is used when the attacker cannot use the same channel to launch the attack and gather results or when the server responses are unstable. This technique relies on the database server making an out-of-band request (e.g., HTTP or DNS) to send the query result to the attacker. HTTP is normally used in out-of-band SQL injection to send the query result to the attacker's server. We will discuss it in detail in this room.

Each type of SQL injection technique has its advantages and challenges. Understanding these techniques is crucial for identifying and mitigating SQL injection vulnerabilities in web applications. In-band SQL Injection is easy to exploit and detect but noisy and can be easily monitored. Inferential (Blind) SQL Injection is more challenging to exploit and requires multiple requests but can be used when detailed error messages are unavailable. Out-of-band SQL Injection is less common and highly effective, requires external server control, and relies on the database’s ability to make out-of-band requests. By mastering these techniques, penetration testers can effectively identify and exploit SQL injection vulnerabilities, helping organizations secure their web applications against these critical threats.



## second order SQL injection

Second-order SQL injection, also known as stored SQL injection, exploits vulnerabilities where user-supplied input is saved and subsequently used in a different part of the application, possibly after some initial processing. This type of attack is more insidious because the malicious SQL code does not need to immediately result in a SQL syntax error or other obvious issues, making it harder to detect with standard input validation techniques. The injection occurs upon the second use of the data when it is retrieved and used in a SQL command, hence the name "**Second Order**".

```
login form
|___ select * books where book_title='intro to PHP'
       |____ book_title=12345';DROP TABLE hello;
```

> [!danger] The danger of Second-Order SQL Injection lies in its ability to bypass typical front-end defences like basic input validation or sanitisation, which only occur at the point of initial data entry. Since the payload does not cause disruption during the first step, it can be overlooked until it's too late, making the attack particularly stealthy.


**Example**  
We will be using a book review application. The application allows users to add new books via a web page (`add.php`). Users are prompted to provide details about the book they wish to add to the database. You can access the app at `http://MACHINE_IP/second/add.php`[.](http://machine_ip/case1.) The data collected includes the `SSN`, `book_name`, and `author`. Let's consider adding a book with the following details: **SSN: UI00012**, **Book Name: Intro to PHP**, **Author: Tim**. This information is input through a form on the `add.php` page, and upon submission, it is stored in the **BookStore** database as shown below:
```
Book SSN:
U10012

Book Name:
Intro to PHP

Author:
Tim

[Add Book]
```



> [! info] As we know, Second-Order SQL injection is notably challenging to identify. Unlike traditional SQL Injection, which exploits real-time processing vulnerabilities, it occurs when data previously stored in a database is later used in a SQL query. Detecting this vulnerability often requires understanding how data flows through the application and is reused, necessitating a deep knowledge of the backend operations.


Consider the PHP code snippet used in our application for adding books:

```php
if (isset($_POST['submit'])) { 
	$ssn = $conn->real_escape_string($_POST['ssn']); 
	$book_name = $conn->real_escape_string($_POST['book_name']); 
	$author = $conn->real_escape_string($_POST['author']); 
	$sql = "INSERT INTO books (ssn, book_name, author) VALUES ('$ssn', '$book_name', '$author')"; 
	
	if ($conn->query($sql) === TRUE) { 
		echo "<p class='text-green-500'>New book added successfully</p>"; } 
	else { 
		echo "<p class='text-red-500'>Error: " . $conn->error . "</p>"; 
	} 
}
```

The code uses the `real_escape_string()` method to escape special characters in the inputs. While this method can mitigate some risks of immediate SQL Injection by escaping single quotes and other SQL meta-characters, it does not secure the application against Second Order SQLi. The key issue here is the lack of parameterised queries, which is essential for preventing SQL injection attacks. When data is inserted using the `real_escape_string()` method, it might include payload characters that don't cause immediate harm but can be activated upon subsequent retrieval and use in another SQL query. 

For instance, inserting a book with a name like `Intro to PHP'; DROP TABLE books;--` might not affect the **INSERT** operation but could have serious implications if the book name is later used in another SQL context without proper handling.

```
SSN     Book Name      Author
U10012  Intro to PHP   Tim
test'   hello          hello
```

Here we go, the SSN `test'` is successfully inserted into the database. The application includes a feature to update book details through an interface like `update.php`. This interface might display existing book details in editable form fields, retrieved based on earlier stored data, and then update them based on user input.

By manipulating the update feature, the tester can see if the malicious payload added during the insertion phase gets executed during the update operation. If the application fails to employ proper security practices at this stage, the earlier injected payload `'; DROP TABLE books; --` could be activated, leading to the execution of a harmful SQL command like dropping a table.

`http://MACHINE_IP/second/update.php` to update any book details.

update.php
```php
if ( isset($_POST['update'])) { 
	$unique_id = $_POST['update']; 
	$ssn = $_POST['ssn_' . $unique_id]; 
	$new_book_name = $_POST['new_book_name_' . $unique_id]; 
	$new_author = $_POST['new_author_' . $unique_id]; 
	
	$update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
```

- checks if request method is POST
- checks if update button pressed
- code enters data


### prep the payload

We know that we can add or modify the book details based on their `ssn`. The normal query for updating a book might look like this:

```php
UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '123123';
```

attacker
```php
12345'; UPDATE books SET book_name = 'Hacked'; --
```


```
SSN                          Book Name      Author
U10012                       Intro to PHP   Tim
test'                        hello          hello
12345'; UPDATE books 
SET book_name='hacked';--    test           Hacker
```

- **Malicious SQL Execution**: After that, when the admin or any other user visits the URL `http://MACHINE_IP/second/update.php` and updates the book, the inserted payload breaks out of the intended SQL command structure and injects a new command that updates all records in the books table. Let's visit the page  `http://MACHINE_IP/second/update.php page`, update the book name to anything, and click the **Update** button. The code will execute the following statement in the backend.

```php
UPDATE books SET book_name = 'Testing', author = 'Hacker' WHERE ssn = '12345'; Update books set book_name ="hacked"; --'; INSERT INTO logs (page) VALUES ('update.php');
```

- **Commenting Out the Rest**: The double dash (`--`) is an SQL comment symbol. Anything following `--` will be ignored by the SQL server, effectively neutralising any remaining parts of the original SQL statement that could cause errors or reveal the attack. Once the above query is executed, it will change the name of all the books to **hacked**, as shown below:

```
SSN                          Book Name      Author
U10012                       hacked         Tim
test'                        hacked         hello
12345'; UPDATE books 
SET book_name='hacked';--    hacked         Hacker
```



```
What is the flag value after updating the title of all books to "compromised"?


What is the flag value once you drop the table hello from the database?



```





## filter evasion techniques

In advanced SQL injection attacks, evading filters is crucial for successfully exploiting vulnerabilities. Modern web applications often implement defensive measures to sanitise or block common attack patterns, making simple SQL injection attempts ineffective. As pentesters, we must adapt using more sophisticated techniques to bypass these filters. 

This section will cover such methods, including **character encoding**, **no-quote** SQL injection, and handling scenarios where **spaces** cannot be used. We can effectively penetrate web applications with stringent input validation and security controls by understanding and applying these techniques.


### Character Encoding  

Character encoding involves converting special characters in the SQL injection payload into encoded forms that may bypass input filters.  

- **URL Encoding**: URL encoding is a common method where characters are represented using a percent (%) sign followed by their ASCII value in hexadecimal. For example, the payload `' OR 1=1--` can be encoded as `%27%20OR%201%3D1--`. This encoding can help the input pass through web application filters and be decoded by the database, which might not recognise it as malicious during initial processing.
- **Hexadecimal Encoding**: Hexadecimal encoding is another effective technique for constructing SQL queries using hexadecimal values. For instance, the query `SELECT * FROM users WHERE name = 'admin'` can be encoded as `SELECT * FROM users WHERE name = 0x61646d696e`. By representing characters as hexadecimal numbers, the attacker can bypass filters that do not decode these values before processing the input.
- `Unicode Encoding`: Unicode encoding represents characters using Unicode escape sequences. For example, the string `admin` can be encoded as `\u0061\u0064\u006d\u0069\u006e`. This method can bypass filters that only check for specific ASCII characters, as the database will correctly process the encoded input.


**Example**

In this example, we explore how developers can implement basic filtering to prevent SQL injection attacks by removing specific keywords and characters from user input. However, we will also see how attackers can bypass these defences using character encoding techniques like URL encoding.

**Note**: In the upcoming exercises, we will use databases that are different from the last ones. You can access the page at `http://MACHINE_IP/encoding/`.

Here's the PHP code (search_books.php) that handles the search functionality:

```php
$book_name = $_GET['book_name'] ?? ''; $special_chars = array("OR", "or", "AND", "and" , "UNION", "SELECT"); $book_name = str_replace($special_chars, '', $book_name); $sql = "SELECT * FROM books WHERE book_name = '$book_name'"; echo "<p>Generated SQL Query: $sql</p>"; $result = $conn->query($sql) or die("Error: " . $conn->error . " (Error Code: " . $conn->errno . ")"); if ($result->num_rows > 0) { while ($row = $result->fetch_assoc()) {}
```

```js
function searchBooks() { const bookName = document.getElementById('book_name').value; const xhr = new XMLHttpRequest(); xhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true); xhr.onload = function() { if (this.status === 200) { document.getElementById('results').innerHTML = this.responseText;
```

In the above example, the developer has implemented a basic defence mechanism to prevent SQL injection attacks by removing specific SQL keywords, such as `OR`, `AND`, `UNION`, and `SELECT`. The filtering uses the `str_replace` function, which strips these keywords from the user input before they are included in the SQL query. This filtering approach aims to make it harder for attackers to inject malicious SQL commands, as these keywords are essential for many SQL injection payloads.

Preparing the Payload

Let's go through the process of preparing an SQL injection payload step-by-step, showing how URL encoding can bypass basic defences. First, let’s see what happens with a normal input that contains special characters or SQL keywords. When we search for a book named `Intro to PHP`, we get the successful result as shown below:

```
search for a book
[ intro to php ]
[search]

Generated SQL Query: SELECT * FROM books WHERE book_name='intro to PHP'

Book ID: 1
Name: Intro to PHP
Author: 1337
```

The SQL query is not executing correctly, which probably means there is a chance of SQL Injection. Let's try to inject the payload "`Intro to PHP' OR 1=1`". returns an error for syntax, `str_replace` function takes out the OR keyword and single quotes

To bypass the filtering, we need to encode the input using URL encoding, which represents special characters and keywords in a way that the filter does not recognise and remove. Here is the example payload `1%27%20||%201=1%20--+`.

- `%27` is the URL encoding for the single quote (').
- `%20` is the URL encoding for a space ( ).
- `||` represents the SQL OR operator.
- `%3D` is the URL encoding for the equals sign (=).
- `%2D%2D` is the URL encoding for --, which starts a comment in SQL.

In the above payload, `1'` closes the current string or value in the SQL query. For example, if the query is looking for a book name that matches 1, adding `'` closes the string, making the rest of the input part of the SQL statement. `|| 1=1` part uses the SQL `OR` operator to add a condition that is always true. This condition ensures that the query returns true for all records, bypassing the original condition that was supposed to restrict the results. Similarly, `--` starts a comment in SQL, causing the database to ignore the rest of the query. This is useful to terminate any remaining part of the query that might cause syntax errors or unwanted conditions. To ensure proper spacing, `+` add a space after the comment, ensuring that the comment is properly terminated and there are no syntax issues.

From the console, we can see that clicking the search button makes an AJAX call to `search_book.php`.
Let's use the payload directly on the PHP page to avoid unnecessary tweaking/validation from the client.  Let's visit the URL [http://MACHINE_IP/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1](http://machine_ip/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1) with the standard payload `Intro to PHP' OR 1=1`, and you will see an error.

Now, URL encode the payload `Intro to PHP' || 1=1 --+` using [Cyber Chef](https://gchq.github.io/CyberChef/#recipe=URL_Encode(false)) and try to access the URL with an updated payload. We will get the following output dumping the complete information:

The payload works because URL encoding represents the special characters and SQL keywords in a way that bypasses the filtering mechanism. When the server decodes the URL-encoded input, it restores the special characters and keywords, allowing the SQL injection to execute successfully. Using URL encoding, attackers can craft payloads that bypass basic input filtering mechanisms designed to block SQL injection. This demonstrates the importance of using more robust defences, such as parameterised queries and prepared statements, which can prevent SQL injection attacks regardless of the input's encoding.


```
What is the MySQL error code once an invalid query is entered with bad characters?
1064

What is the name of the book where **book ID=6**?


```
















































































